# Assignment One Feedback
## Tutor Comment

Hi Prabhjot, fantastic work on completing up to Task 10 and attempting task 11. Your solutions were elegant and your code was nicely formatted. You had helpful comments explaining pieces of your code, making your code more readable. Your use of git was excellent, with regular commits and informative commit messages. Great work Prabhjot, good luck for the rest of the semester. 


## Mark

**  3.75/5.0**

## Miscellaneous marks

| Level | Requirement | Result |
|:-:|---|:-:|
|P|Forked assignment 1 repository | 0.5/0.5 |
|P|Originality statement edited, committed, pushed | 0.5/0.5 |
|P|Git log file reveals healthy use of Git | 0.25/0.25 |
|P|Edited classes compile correctly | 0.25/0.25 |
|CR|Code is of high quality | 0.5/0.5 |
|HD|Solution is outstanding in its design and implementation | 0.0/0.5 |

**Total for miscellaneous marks:** 2.0/2.5

## Test results
```
Test Name   Tests Passed  Weighting     Score
-----              -----      -----     -----
task1                4/4        0.1       0.1
task2                9/9        0.3       0.3
task3                3/3        0.2       0.2
task4                3/3        0.1       0.1
task5                5/5        0.1       0.1
task6                3/3        0.2       0.2
task7                3/3        0.1       0.1
task8                2/2        0.2       0.2
task9                3/3        0.2       0.2
task10               4/4       0.25      0.25
task11               0/5       0.25       0.0
task12               0/4       0.25       0.0
task13               0/3       0.25       0.0
-----              -----     Total:  1.75/2.5
```
## Originality statement
# IMPORTANT: It is very important that you correctly complete this originality
# statement.
#
# This is your statement of your submitted work being your own.
# Incorrectly filling out this statement could lead to charges
# of academic misconduct.
# 
# For information on how to fill this out correctly, see
# https://cs.anu.edu.au/courses/comp1110/help/faq/09-originality/
#

declaration: >-
  I declare that everything I have submitted in this assignment is entirely my
  own work, with the following exceptions:
# Use this to list names of people who you collaborated with, and a
# comment about what you collaborated on.
#
# Add as many "name+comment" entries as necessary
# (or remove it altogether if you haven't collaborated with anyone)
# Use this to list any code that you used that you did not write,
# aside from code provided by the lecturer.  Provide a comment
# explaining your use and the URL to that code and the licence for
# that code
#
# Add as many "url+licence+comment" entries as necessary
# (or remove it altogether if you haven't used any external code)
# Use this to list any assets (artwork, sound, etc) that you used.
# Provide a comment explaining your use of that asset and the URL
# and license for the asset
#
# Add as many "url+licence+comment" entries as necessary
# (or remove it altogether if you haven't used any external assets)
# sign *your* name and uid here
name: Prabhjot Kaur Dhawan
uid: u7153455
## Git Log
```
commit 0c1a53606daca7eca82eb27257666b22937d9d69
Author: Prabhjot <u7153455@anu.edu.au>
Date:   Fri Aug 14 07:20:08 2020 +0530

    Couldn't complete task 11 but passed tasks 1-10

commit 84dcd96f8b2a8f01cd41d076ae0ae211bf394992
Author: Prabhjot <u7153455@anu.edu.au>
Date:   Fri Aug 14 07:03:40 2020 +0530

    Couldn't complete task 11 but passed tasks 1-10

commit 8b0dfa2b8d2d51b3dc02d9007b6dd2336d4d1a1f
Author: Prabhjot <u7153455@anu.edu.au>
Date:   Thu Aug 13 05:22:42 2020 +0530

    Task 10 Done

commit a7a3cf9f29925416fcf84b555045f8b4b7cece3d
Author: Prabhjot <u7153455@anu.edu.au>
Date:   Thu Aug 13 05:20:34 2020 +0530

    Task 9 done and update 8

commit c33f7a9165cb9096258ff15c351a489c80cba4fe
Author: Prabhjot <u7153455@anu.edu.au>
Date:   Thu Aug 13 02:17:38 2020 +0530

    Task 9 done and update 8

commit 62e22a52ca53b605b7f8fd90db22401e90542a45
Author: Prabhjot <u7153455@anu.edu.au>
Date:   Thu Aug 13 01:09:25 2020 +0530

    Task 8 done

commit 23864bf88b1d54205b88b258a70461b75a5ecb95
Author: Prabhjot <u7153455@anu.edu.au>
Date:   Wed Aug 12 10:26:12 2020 +0530

    Task 7 done

commit fd83b891c1fbd1dd6df95c3186485c1e119e75c3
Author: Prabhjot <u7153455@anu.edu.au>
Date:   Tue Aug 11 12:07:25 2020 +0530

    Task 6

commit f154be558cac4d81d207fac3d14c1e180a233a87
Author: Prabhjot <u7153455@anu.edu.au>
Date:   Tue Aug 11 11:32:52 2020 +0530

    Originality 2

commit 0307c04fe795c485c5fb9d90f756462bc62a4add
Author: Prabhjot <u7153455@anu.edu.au>
Date:   Tue Aug 11 11:30:03 2020 +0530

    error Direction

commit f940a7431c7dc026315734a7af47e06670a44b6a
Author: Prabhjot <u7153455@anu.edu.au>
Date:   Tue Aug 11 11:27:29 2020 +0530

    Statement update

commit 11e06a96d2fca5d1051f64dd5e9949c153c2aba4
Author: Prabhjot <u7153455@anu.edu.au>
Date:   Tue Aug 11 10:05:51 2020 +0530

    originality statement check

commit 5acba7326fd16013e488ec48a8bba678baf3b129
Author: Prabhjot <u7153455@anu.edu.au>
Date:   Tue Aug 11 09:58:01 2020 +0530

    Signed originality statement

commit 760fb7c69ac84835570abbc31b7502d23b4accaf
Author: Prabhjot <u7153455@anu.edu.au>
Date:   Tue Aug 11 09:54:06 2020 +0530

    Passed 4 tests

commit 2a7dfcd52d995a8710f46bee9fc9b60a49727aab
Author: Steve Blackburn <steve.blackburn@anu.edu.au>
Date:   Mon Aug 3 19:50:41 2020 +1000

    Fixed GUI bug

commit 141fbc6b65495285212c6818763957ecc7a149a8
Author: Steve Blackburn <steve.blackburn@anu.edu.au>
Date:   Fri Jul 31 23:16:02 2020 +1000

    Correction to additional test case

commit 5b43f286279d899a6aa92f2f568a3f12e93f668d
Author: Steve Blackburn <steve.blackburn@anu.edu.au>
Date:   Fri Jul 31 21:57:44 2020 +1000

    Additional test case

commit 8aa7d205a93cb3df086ba15f2f7309871f272abc
Author: Steve Blackburn <steve.blackburn@anu.edu.au>
Date:   Fri Jul 31 09:41:18 2020 +1000

    Fix problem of null tiles leading to NPEs in some situations

commit df6cc12357ee8ce98f0f605dbcd3b859f2410f03
Author: Steve Blackburn <steve.blackburn@anu.edu.au>
Date:   Wed Jul 29 20:07:18 2020 +1000

    Correction and clarification

commit ea45758dca7883f625aff63cc8b8986f487ddb82
Author: Steve Blackburn <steve.blackburn@anu.edu.au>
Date:   Wed Jul 29 19:58:20 2020 +1000

    Allow GUI to work even with incomplete tasks

commit 1518efe703e6e3f81c518743adf515e213530139
Author: Steve Blackburn <steve.blackburn@anu.edu.au>
Date:   Wed Jul 29 17:19:40 2020 +1000

    Initial import
```
## Changes
``` diff
Only in comp1110-ass1: feedback.md
diff -ru -x .git /Users/zaran/Desktop/comp1110-tutors/bin/../master/comp1110-ass1/originality.yml comp1110-ass1/originality.yml
--- /Users/zaran/Desktop/comp1110-tutors/bin/../master/comp1110-ass1/originality.yml	2020-08-21 13:38:11.000000000 +1000
+++ comp1110-ass1/originality.yml	2020-08-21 13:40:48.000000000 +1000
@@ -12,17 +12,11 @@
 declaration: >-
   I declare that everything I have submitted in this assignment is entirely my
   own work, with the following exceptions:
-
-
 # Use this to list names of people who you collaborated with, and a
 # comment about what you collaborated on.
 #
 # Add as many "name+comment" entries as necessary
 # (or remove it altogether if you haven't collaborated with anyone)
-collaboration:
-  - name:
-    comment: >-
-
 # Use this to list any code that you used that you did not write,
 # aside from code provided by the lecturer.  Provide a comment
 # explaining your use and the URL to that code and the licence for
@@ -30,23 +24,12 @@
 #
 # Add as many "url+licence+comment" entries as necessary
 # (or remove it altogether if you haven't used any external code)
-code:
-  - comment:
-    url:
-    licence:
-
 # Use this to list any assets (artwork, sound, etc) that you used.
 # Provide a comment explaining your use of that asset and the URL
 # and license for the asset
 #
 # Add as many "url+licence+comment" entries as necessary
 # (or remove it altogether if you haven't used any external assets)
-assets:
-  - comment:
-    url:
-    licence:
-
-
 # sign *your* name and uid here
-name:
-uid:
+name: Prabhjot Kaur Dhawan
+uid: u7153455
diff -ru -x .git /Users/zaran/Desktop/comp1110-tutors/bin/../master/comp1110-ass1/src/comp1110/ass1/Direction.java comp1110-ass1/src/comp1110/ass1/Direction.java
--- /Users/zaran/Desktop/comp1110-tutors/bin/../master/comp1110-ass1/src/comp1110/ass1/Direction.java	2020-08-21 13:38:11.000000000 +1000
+++ comp1110-ass1/src/comp1110/ass1/Direction.java	2020-08-21 13:40:48.000000000 +1000
@@ -1,5 +1,7 @@
 package comp1110.ass1;
 
+
+
 /**
  * This enumeration type represents the four cardinal directions
  *
@@ -30,7 +32,20 @@
      * @return the `Direction` associated with the char.
      */
     public static Direction fromChar(char direction) {
-        return NORTH; // FIXME Task 2.a (P)
+       // char a=direction;
+        Direction d = null;
+
+        if(direction=='N')
+            d= NORTH;
+        else if(direction=='S')
+            d= SOUTH;
+        else if(direction=='W')
+            d= WEST;
+        else if(direction=='E')
+            d= EAST;
+
+
+        return d; // Done
     }
 
     /**
@@ -41,7 +56,17 @@
      * @return The first character of the name of the direction
      */
     public char toChar() {
-        return ' ';  // FIXME Task 2.b (P)
+        char a=' ';
+        if(this==NORTH)
+            a='N';
+        else if(this==SOUTH)
+            a='S';
+        else if(this==WEST)
+            a='W';
+        else if(this==EAST)
+            a='E';
+
+        return a;  // Fixed
     }
 
     /**
@@ -50,7 +75,17 @@
      * for example: the opposite Direction of 'NORTH' would be 'SOUTH'.
      */
     public Direction getOpposite() {
-       return null; // FIXME Task 3 (P)
+        Direction a = null;
+
+        if(this==NORTH)
+            a=SOUTH;
+        else if(this==SOUTH)
+            a=NORTH;
+        else if(this==WEST)
+            a=EAST;
+        else if(this==EAST)
+            a=WEST;
+       return a; // Done
     }
 
     /** @return this direction's symbol as a string */
diff -ru -x .git /Users/zaran/Desktop/comp1110-tutors/bin/../master/comp1110-ass1/src/comp1110/ass1/Objective.java comp1110-ass1/src/comp1110/ass1/Objective.java
--- /Users/zaran/Desktop/comp1110-tutors/bin/../master/comp1110-ass1/src/comp1110/ass1/Objective.java	2020-08-21 13:38:11.000000000 +1000
+++ comp1110-ass1/src/comp1110/ass1/Objective.java	2020-08-21 13:40:48.000000000 +1000
@@ -1,5 +1,8 @@
 package comp1110.ass1;
 
+import java.util.Random;
+import java.util.concurrent.ThreadLocalRandom;
+
 /**
  * An objective is a certain challenge that the player must solve to complete a
  * game of Temple Trap. An objective has two fields:
@@ -154,7 +157,24 @@
      */
     public static Objective newObjective(int difficulty) {
         assert difficulty >= 0 && difficulty <= 4;
-        return OBJECTIVES[0]; // FIXME Task 5 (P)
+
+        //Initialisation
+        Random r=new Random();
+        int level=0;
+
+        //Conditions for level selection
+        if(difficulty==0)
+            level= ThreadLocalRandom.current().nextInt(1, 12);
+        else if(difficulty==1)
+            level= ThreadLocalRandom.current().nextInt(13, 24);
+        else if(difficulty==2)
+            level= ThreadLocalRandom.current().nextInt(25, 36);
+        else if(difficulty==3)
+            level= ThreadLocalRandom.current().nextInt(37, 48);
+        else if(difficulty==4)
+            level= ThreadLocalRandom.current().nextInt(49, 60);
+
+        return OBJECTIVES[level];//Done Task 5
     }
 
     public String getInitialState() {
diff -ru -x .git /Users/zaran/Desktop/comp1110-tutors/bin/../master/comp1110-ass1/src/comp1110/ass1/TempleTrap.java comp1110-ass1/src/comp1110/ass1/TempleTrap.java
--- /Users/zaran/Desktop/comp1110-tutors/bin/../master/comp1110-ass1/src/comp1110/ass1/TempleTrap.java	2020-08-21 13:38:11.000000000 +1000
+++ comp1110-ass1/src/comp1110/ass1/TempleTrap.java	2020-08-21 13:40:48.000000000 +1000
@@ -195,7 +195,7 @@
         pegPosition = next;
     }
 
-    /** START OF ASSIGNMENT TASKS */
+    /* START OF ASSIGNMENT TASKS */
 
     /**
      * Given a boardState, determine whether it is valid.
@@ -211,7 +211,68 @@
      * @return true if the boardState is valid, false if it is invalid.
      */
     public static boolean isBoardStateValid(String boardState) {
-        return false;  // FIXME Task 4 (P)
+        boolean result ;
+        char[] b;
+        int count=0;
+        char[] positions=new char[boardState.length()];
+        int check_peg=0;
+
+        // creating array
+        b=boardState.toCharArray();
+        if(boardState.length()!=17)
+            count++;
+       // System.out.println(count);
+
+        //checking direction character
+        for(int i=0;i<boardState.length()-1;i=i+2){
+            // System.out.println(b[i]);
+            if(b[i]!='N' && b[i] !='W' && b[i] !='S' && b[i]!='E' )
+                count++;}
+       // System.out.println(count);
+
+        // checking position number
+        for(int k=1;k<=boardState.length()-1;k=k+2){
+            if(b[k]!='0' && b[k]!='1' && b[k]!='2' && b[k]!='3' && b[k]!='4' && b[k]!='5' && b[k]!='6' && b[k]!='7' && b[k]!='8')
+                count++;}
+       // System.out.println(count);
+
+        // creating array for only positions
+        for(int p=1;p<=boardState.length()-2;p=p+2){
+            positions[p]=b[p];
+        }
+        Arrays.sort(positions);
+
+        //checking no tile shares same position
+        for(int l=9;l<=boardState.length()-2;l++){
+            if(positions[l+1]==positions[l]){
+                //System.out.println(positions[l+1]);
+                count++;}
+        }
+      //  System.out.println(count);
+
+        // checking peg is not placed on vacant position
+        for(int c=8;c<=boardState.length()-1;c++){
+            if(positions[c]==b[boardState.length()-1])
+                check_peg++;
+        }if(check_peg!=1)
+            count++;
+       // System.out.println(count);
+
+        // checking peg is not located on green tile
+        for(int m=1;m<=5;m=m+2){
+            if(b[m]==b[boardState.length()-1])
+                count++;
+        }
+        //System.out.println(count);
+
+        if(count==0)
+            result=true;
+        else
+            result=false;
+
+
+
+        return result;  //
     }
 
     /**
@@ -223,7 +284,29 @@
      * finish position, or OFF_BOARD if it is off the board.
      */
     public static int getNextPosition(int pos, Direction dir) {
-        return -3; // FIXME Task 6 (P)
+       int a = 0;
+        if (dir==Direction.WEST && (pos==0))
+           a=FINISH_POSITION;
+        else if(dir==Direction.WEST &&(pos==3 || pos==6))
+            a=OFF_BOARD;
+        else if(dir==Direction.EAST &&(pos==2 || pos==5 || pos==8))
+            a=OFF_BOARD;
+        else if(dir==Direction.NORTH &&(pos==0 || pos==1 || pos==2))
+            a=OFF_BOARD;
+        else if(dir==Direction.SOUTH &&(pos==6 || pos==7 || pos==8))
+            a=OFF_BOARD;
+        else if(dir==Direction.EAST)
+            a=pos+1;
+        else if(dir==Direction.WEST)
+            a=pos-1;
+        else if(dir==Direction.NORTH)
+            a=pos-3;
+        else if(dir==Direction.SOUTH)
+            a=pos+3;
+
+
+
+        return a; // Done
     }
 
 
@@ -238,7 +321,51 @@
      * @return true if the tile can be moved, false otherwise
      */
     public boolean canMoveTile(Tile tile) {
-        return false;  // FIXME Task 8 (CR)
+        //Initialisation
+        String a=getBoardState();
+        int[] index={1,3,5,7,9,11,13,15,16};
+        char[] pos={'0','1','2','3','4','5','6','7','8'};
+        char[] BoardS_pos=new char[8];
+        int tile_pos=tile.position;
+        int miss = 0;
+        boolean check;
+        int count;
+
+        // Creating array for board state
+        char[] bs=a.toCharArray();
+
+        //Creating array for only positions of tiles
+        for(int j=0;j<=7;j++) {
+            int f=index[j];
+            BoardS_pos[j] = bs[f];}
+
+
+        //Finding null space on board
+        for(int i=0;i<9;i++){
+            count=0;
+            for(int k=0;k<8;k++){
+                if(pos[i]!=BoardS_pos[k])
+                    count++;
+            } if(count==8) {
+                miss=i;
+            }}
+
+        //Peg position
+        char p=bs[16];
+        int pos_peg=Character.getNumericValue(p);
+
+
+        //Conditions to move tile
+        if(tile_pos==pos_peg)
+            check=false;
+        else if(tile_pos != pos_peg && (tile_pos+1==miss && tile_pos!=2 && tile_pos!=5) || miss ==tile_pos-1 || miss==tile_pos+3 || miss==tile_pos-3)
+            check=true;
+        else
+            check=false;
+
+
+
+        return check;  // Done Task 8
     }
 
     /**
@@ -253,9 +380,82 @@
      * @return true if the movement is valid, false if it is invalid.
      */
     public boolean isTileMovementValid(Tile tile, Direction direction) {
-        return false;  // FIXME Task 9 (CR)
+        //Initialisation
+        String a=getBoardState();
+        int tile_pos=tile.position;
+        boolean check = false;
+        char[] num_bs=new char[8];
+        int[] ind={1,3,5,7,9,11,13,15,16};
+        char[] pos={'0','1','2','3','4','5','6','7','8'};
+        int count;
+        int miss = 0;
+
+        // Creating array for board state and getting position of peg
+        char[] bs=a.toCharArray();
+        int pos_peg=Character.getNumericValue(bs[16]);
+
+
+        //Creating array for tile positions only
+        for(int j=0;j<=7;j++) {
+            int f=ind[j];
+            num_bs[j] = bs[f];}
+
+
+        //Finding null space on board
+        for(int i=0;i<9;i++){
+            count=0;
+            for(int k=0;k<8;k++){
+                if(pos[i]!=num_bs[k])
+                    count++;
+            } if(count==8) {
+                miss =i ;
+            }}
+
+
+        // Checking conditions for valid tile movement
+        if(direction==Direction.NORTH &&(tile_pos==0 || tile_pos==1 || tile_pos==2))
+            check=false;
+        else if(direction==Direction.SOUTH && (tile_pos==6 || tile_pos==7 || tile_pos==8))
+            check=false;
+        else if(direction==Direction.WEST && (tile_pos==0 || tile_pos==3 || tile_pos==6))
+            check=false;
+        else if(direction==Direction.EAST && (tile_pos==2 || tile_pos==5 || tile_pos==8))
+            check=false;
+        else if(tile_pos==pos_peg)
+            check=false;
+        else if((miss==tile_pos+3 && direction==Direction.SOUTH)||(miss==tile_pos-3 && direction==Direction.NORTH))
+            check=true;
+        else if((miss==tile_pos-1 && direction==Direction.WEST)||(miss==tile_pos+1 && direction==Direction.EAST && tile_pos!=2 && tile_pos!=5))
+            check=true;
+
+            
+        
+
+        return check;  // Task 9 done
+    }
+
+    public Direction getDir(String a){
+        Direction temp=null;
+        switch(a){
+            case "N":
+                temp=Direction.NORTH;
+                break;
+            case "S":
+                temp=Direction.SOUTH;
+                break;
+            case " W":
+                temp=Direction.WEST;
+                break;
+            case "E":
+                temp=Direction.EAST;
+                break;
+
+        }
+        return temp;
     }
 
+
+
     /**
      * This method returns a path for one step of the peg from the starting tile to the
      * first valid stopping position from a specified exit.  The finishing point is considered
@@ -279,11 +479,332 @@
      * @param viaA  If true, leave the start tile via exit A, otherwise use exit B
      * @return a string representing the path to the next step for the peg (as a series of
      * directions and the endpoint), or null if there is no such path.
+     *
      */
+
     public String getPegPathStep(Tile start, boolean viaA) {
-        return null;  // FIXME Task 11 (D)
+        //Initialisation
+        int peg_pos=start.position;
+        System.out.println("peg pos "+peg_pos);
+        viaA=true;
+
+        String a=getBoardState();
+        char[] bs;
+        char temp;
+        int temp2;
+        int one_pos;
+        int two_pos ;
+        String peg_path="";
+
+
+        ArrayList<String> ori_arr=new ArrayList<>();
+        ArrayList<Integer> pos_arr=new ArrayList<>();
+        ArrayList<Integer> pos_check=new ArrayList<>();
+
+        TileName [] type_ar={TileName.PLUS,TileName.EQUALS,TileName.SQUARE,TileName.TRIANGLE,TileName.EQUALS,TileName.CIRCLE,TileName.STAR,TileName.DIAMOND};
+
+        TileName equals=TileName.EQUALS;
+        TileName plus=TileName.PLUS;
+        TileName diamond=TileName.DIAMOND;
+        TileName square=TileName.SQUARE;
+        TileName star=TileName.STAR;
+        TileName triangle=TileName.TRIANGLE;
+        TileName cross=TileName.CROSS;
+        TileName circle=TileName.CIRCLE;
+
+        Direction north=Direction.NORTH;
+        Direction south=Direction.SOUTH;
+        Direction west=Direction.WEST;
+        Direction east=Direction.EAST;
+
+        bs=a.toCharArray();
+
+        System.out.println(bs);
+
+        String[] bs_st = new String[17];
+
+        for(int j=0;j<17;j++){
+            temp=bs[j];
+            bs_st[j]=String.valueOf(temp);
+        }
+
+        for(int i=0;i<16;i=i+2){
+            ori_arr.add(bs_st[i]);
+        }
+
+        for(int k=1;k<16;k=k+2){
+            temp2=Integer.parseInt(bs_st[k]);
+            pos_arr.add(temp2);
+        }
+
+        switch(peg_pos) {
+            case 0:
+                pos_check.add(1);
+                pos_check.add(3);
+                break;
+            case 1:
+                pos_check.add(0);
+                pos_check.add(4);
+                pos_check.add(2);
+                break;
+            case 2:
+                pos_check.add(1);
+                pos_check.add(5);
+                break;
+            case 3:
+                pos_check.add(0);
+                pos_check.add(4);
+                pos_check.add(6);
+                break;
+            case 4:
+                pos_check.add(1);
+                pos_check.add(3);
+                pos_check.add(7);
+                pos_check.add(5);
+                break;
+            case 5:
+                pos_check.add(2);
+                pos_check.add(4);
+                pos_check.add(8);
+                break;
+            case 6:
+                pos_check.add(3);
+                pos_check.add(7);
+                break;
+            case 7:
+                pos_check.add(6);
+                pos_check.add(4);
+                pos_check.add(8);
+                break;
+            case 8:
+                pos_check.add(7);
+                pos_check.add(5);
+                break;
+        }
+
+        System.out.println("pos_check "+pos_check);
+        int ind=pos_arr.indexOf(peg_pos);
+
+
+        String one_o=ori_arr.get(ind);
+        Direction one_d=getDir(one_o);
+        TileName one_t=type_ar[ind];
+        one_pos=peg_pos;
+
+
+
+
+        for(int h=0;h<pos_check.size();h++) {
+            two_pos = pos_check.get(h);// getting value of adjacent tile
+
+            System.out.println("Position of adjacent tile " + two_pos);
+            boolean check_pos = pos_arr.contains(two_pos);
+            if (check_pos == false)
+                continue;
+            System.out.println("pos_check " + pos_check);
+            System.out.println(two_pos);
+
+            int ind2 = pos_arr.indexOf(two_pos);// getting index of position 2
+            String two_o = ori_arr.get(ind2);
+            Direction two_d = getDir(two_o);
+            TileName two_t = type_ar[ind2];
+
+
+            System.out.println(pos_arr);
+            System.out.println(ori_arr);
+
+            System.out.println("one_t " + one_t);
+            System.out.println("one_o " + one_o);
+            System.out.println("one_pos " + one_pos);
+
+            System.out.println("two_t " + two_t);
+            System.out.println("two_o " + two_o);
+            System.out.println("two_pos " + two_pos);
+
+            // GREEN RIGHT
+            if ((one_t == equals && (one_d == north || one_d == south)) || (one_t == square && (one_d == south || one_d == west)) || (one_t == plus && (one_d == north || one_d == south)) || ((one_t == star || one_t == diamond) && one_d == north)) {
+                if (two_pos == one_pos + 1 && one_pos != 2 && one_pos != 5 && one_pos != 8) {
+                    if ((two_t == plus && (two_d == north || two_d == south)) || ((two_t == equals || two_t == square) && (two_d == north || two_d == east)) || (two_t == star && two_d == south) || (two_t == diamond && two_d == south)) {
+                        if (one_d == south)
+                            viaA = false;
+                        if (two_t != plus || two_t != equals || two_t != square) {
+                            System.out.println("reached");
+                            peg_path = peg_path + "E";
+                            peg_pos = peg_pos + 1;
+                            System.out.println("Position of peg after going right green " + peg_pos);
+                            if (one_d==north)
+                                viaA=false;
+
+                        }
+
+                    }
+
+                }
+            }
+
+
+
+            // GREEN UP
+            if (((one_t == equals || one_t == square) && (one_d == east || one_d == south)) || (one_t == plus && (one_d == east || one_d == west)) || ((one_t == star || one_t == diamond) && one_d == west)) {
+                if (two_pos == one_pos - 3 && one_pos != 1 && one_pos != 0 && one_pos != 2) {
+                    System.out.println("Inside green up");
+                    if ((two_t == plus && (two_d == east || two_d == west)) || ((two_t == equals || two_t == square) && (two_d == north || two_d == west)) || ((two_t == star || two_t == diamond) && two_d == east)) {
+                        if (one_d == east)
+                            viaA = false;
+                        if (two_t != plus || two_t != equals || two_t != square) {
+                            System.out.println("reached");
+                            peg_path = peg_path + "N";
+                            peg_pos = peg_pos - 3;
+                            System.out.println("Position of peg after going up green " + peg_pos);
+                            if (one_d==north)
+                                viaA=false;
+
+                        }
+
+                    }
+                }
+
+            }
+
+
+
+
+
+            // GREEN LEFT
+            if ((one_t == equals && (one_d == north || one_d == east)) || (one_t == square && (one_d == north || one_d == east)) || (one_t == plus && (one_d == north || one_d == south)) || ((one_t == star || one_t == diamond) && one_d == south)) {
+                System.out.println("In green left loop 1");
+                if (two_pos == one_pos - 1 && one_pos != 0 && one_pos != 3 && one_pos != 6) {
+                    System.out.println("In green left loop 2");
+                    if ((two_t == plus && (two_d == north || two_d == south)) || ((two_t == equals || two_t == square) && (two_d == south || two_d == west)) || (two_t == star && two_d == north) || (two_t == diamond && two_d == north)) {
+                        System.out.println(" In green left loop 3");
+                        if (two_t != plus || two_t != equals || two_t != square) {
+                            System.out.println("reached");
+                            peg_path = peg_path + "W";
+                            peg_pos = peg_pos - 1;
+                            one_pos=two_pos;
+                            two_pos=one_pos-1;
+                            System.out.println("Position of peg after going left " + peg_pos);
+                            if (one_d==north)
+                                viaA=false;
+
+                        }
+
+
+
+                    }
+                }
+            }
+            //GREEN DOWN
+            if(((one_t==equals || one_t==square) && (one_d==north|| one_d==west)) || (one_t==plus && (one_d==east || one_d==west))|| ((one_t==star || one_t==diamond) && one_d==east)){
+                if(two_pos==one_pos+3 && one_pos!=7 && one_pos!=6 && one_pos!=8){
+                    if((two_t==plus && (two_d==east || two_d==west)) || ((two_t==equals || two_t==square) && (two_d==east || two_d==south)) || ((two_t==star || two_t==diamond) && two_d==west)){
+                        if (two_t != plus || two_t != equals || two_t != square) {
+                            System.out.println("reached");
+                            peg_path = peg_path + "S";
+                            peg_pos = peg_pos + 3;
+                            one_pos=two_pos;
+                            System.out.println("Position of peg after going left " + peg_pos);
+                            if (one_d==north)
+                                viaA=false;
+
+                        }
+
+                    }
+                }
+
+            }
+
+            //BROWN RIGHT
+            if(((one_t==triangle|| one_t==cross|| one_t==circle) && (one_d==south || one_d==west)) ||((one_t==star || one_t== diamond) && one_d==south)){
+                if(two_pos==one_pos+1 && one_pos!=2 && one_pos!=5 && one_pos!=8){
+                    if( ((two_t==triangle || two_t==cross || two_t==circle) && (two_d==north || two_d==east)) || ((two_t==star || two_t==diamond) && two_d==north)){
+                        if (two_t != plus || two_t != equals || two_t != square) {
+                            System.out.println("reached");
+                            peg_path = peg_path + "E";
+                            peg_pos = peg_pos + 1;
+                            System.out.println("Position of peg after going right brown " + peg_pos);
+                            if (one_d==south)
+                                viaA=false;
+
+                        }
+
+                    }
+                }
+
+            }
+
+            //BROWN LEFT
+            if(((one_t==triangle|| one_t==cross|| one_t==circle) && (one_d==north || one_d==east)) ||((one_t==star || one_t== diamond) && one_d==north)){
+                if(two_pos==one_pos-1 && one_pos!=0 && one_pos!=3 && one_pos!=6){
+                    if( ((two_t==triangle || two_t==cross || two_t==circle) && (two_d==south || two_d==west)) || ((two_t==star || two_t==diamond) && two_d==south)){
+                        if (two_t != plus || two_t != equals || two_t != square) {
+                            System.out.println("reached");
+                            peg_path = peg_path + "W";
+                            peg_pos = peg_pos - 1;
+                            System.out.println("Position of peg after going left brown " + peg_pos);
+                            if (one_d==north)
+                                viaA=false;
+
+                        }
+
+                    }
+                }
+
+            }
+
+            //BROWN UP
+            if(((one_t==triangle|| one_t==cross|| one_t==circle) && (one_d==south || one_d==east)) ||((one_t==star || one_t== diamond) && one_d==east)){
+                if(two_pos==one_pos-3 && one_pos!=0 && one_pos!=1 && one_pos!=2){
+                    if( ((two_t==triangle || two_t==cross || two_t==circle) && (two_d==north || two_d==west)) || ((two_t==star || two_t==diamond) && two_d==west)){
+                        if (two_t != plus || two_t != equals || two_t != square) {
+                            System.out.println("reached");
+                            peg_path = peg_path + "N";
+                            peg_pos = peg_pos + 3;
+                            System.out.println("Position of peg after going up brown " + peg_pos);
+                            if (one_d==east)
+                                viaA=false;
+
+                        }
+
+                    }
+                }
+
+            }
+            //BROWN DOWN
+            if(((one_t==triangle|| one_t==cross|| one_t==circle) && (one_d==north || one_d==west)) ||((one_t==star || one_t== diamond) && one_d==west)){
+                if(two_pos==one_pos+3 && one_pos!=6 && one_pos!=7 && one_pos!=8){
+                    if( ((two_t==triangle || two_t==cross || two_t==circle) && (two_d==east || two_d==south)) || ((two_t==star || two_t==diamond) && two_d==east)){
+                        if (two_t != plus || two_t != equals || two_t != square) {
+                            System.out.println("reached");
+                            peg_path = peg_path + "S";
+                            peg_pos = peg_pos + 3;
+                            System.out.println("Position of peg after going down brown " + peg_pos);
+                            if (one_d==west)
+                                viaA=false;
+
+                        }
+
+                    }
+                }
+
+            }
+
+        }
+
+        System.out.println("Peg path " + peg_path);
+        System.out.println("Peg pos " + peg_pos);
+        String temp_path;
+        if (peg_path=="")
+            temp_path=null;
+        else
+            temp_path=peg_path+peg_pos;
+        System.out.println(peg_path);
+
+        return temp_path;  // FIXME Task 11 (D)
     }
 
+
+
     /**
      * Return a path for one step of the peg from its current position.
      *
diff -ru -x .git /Users/zaran/Desktop/comp1110-tutors/bin/../master/comp1110-ass1/src/comp1110/ass1/Tile.java comp1110-ass1/src/comp1110/ass1/Tile.java
--- /Users/zaran/Desktop/comp1110-tutors/bin/../master/comp1110-ass1/src/comp1110/ass1/Tile.java	2020-08-21 13:38:11.000000000 +1000
+++ comp1110-ass1/src/comp1110/ass1/Tile.java	2020-08-21 13:40:48.000000000 +1000
@@ -1,5 +1,7 @@
 package comp1110.ass1;
 
+
+
 /**
  * This class represents a movable tile in the TempleTrap game.   The
  * class encodes which sort of tile it is (tileName), its orientation,
@@ -52,7 +54,11 @@
      * @return An int corresponding to the tile's position on the board.
      */
     public static int placementToPosition(String placement) {
-        return 0;  // FIXME Task 1 (P)
+        char a= placement.charAt(1);
+        String b=Character.toString(a);
+        int c =Integer.parseInt(b);
+
+        return c;  // Converted positional character to string and then to integer
     }
 
     /**
@@ -64,7 +70,19 @@
      * @return A value of type `Direction` corresponding to the tile's orientation on board
      */
     public static Direction placementToOrientation(String placement) {
-       return null;  // FIXME Task 2.c (P)
+        char a = placement.charAt(0);
+        Direction b = null;
+        if (a == 'N')
+            b = Direction.NORTH;
+        else if (a == 'S')
+            b = Direction.SOUTH;
+        else if (a == 'W')
+            b = Direction.WEST;
+        else if (a == 'E')
+            b = Direction.EAST;
+
+
+        return b;
     }
 
     /**
@@ -80,7 +98,27 @@
      * they are not adjacent.
      */
     public Direction adjacencyDirection(Tile other) {
-        return null;  // FIXME Task 7 (CR)
+        //Initialisation
+        Direction check = null;
+        int one=this.position;
+        int two=other.position;
+
+        //Condition to check adjacent tile
+        if((one==2 || one==5 )&&(two==3 || two==6))
+            check=null;
+        else if((one==3 || one==6)&&(two==2|| two==5))
+            check=null;
+        else if(this.position==other.position-1)
+            check=Direction.EAST;
+        else if(this.position==other.position+1)
+            check=Direction.WEST;
+        else if(this.position==other.position+3)
+            check=Direction.NORTH;
+        else if(this.position==other.position-3)
+            check=Direction.SOUTH;
+
+
+        return check;  // Done 
     }
 
     /**
@@ -100,7 +138,114 @@
      * @return true if a peg can legally transit from this tile to the other.
      */
     public boolean canTransit(Tile other) {
-        return false;  // FIXME Task 10 (D)
+
+        //Initialisation
+        int one_pos=this.position;
+        int two_pos=other.position;
+        boolean check = false;
+
+        //Renaming
+        Direction one_o=this.orientation;
+        Direction two_o=other.orientation;
+        TileName one_n=this.tileName;
+        TileName two_n=other.tileName;
+
+        Direction north=Direction.NORTH;
+        Direction south=Direction.SOUTH;
+        Direction west=Direction.WEST;
+        Direction east=Direction.EAST;
+
+        TileName equals=TileName.EQUALS;
+        TileName plus=TileName.PLUS;
+        TileName diamond=TileName.DIAMOND;
+        TileName square=TileName.SQUARE;
+        TileName star=TileName.STAR;
+        TileName triangle=TileName.TRIANGLE;
+        TileName cross=TileName.CROSS;
+        TileName circle=TileName.CIRCLE;
+
+
+       // GREEN RIGHT
+       if((one_n==equals && (one_o==west || one_o==south)) || (one_n==square && (one_o==south || one_o==west)) || (one_n==plus && (one_o==north || one_o==south))|| ((one_n==star || one_n==diamond) && one_o==north)){
+               if(two_pos==one_pos+1 && one_pos!=2 && one_pos!=5 && one_pos!=8){
+                   if((two_n==plus && (two_o==north || two_o==south)) || ((two_n==equals || two_n==square) && (two_o==north || two_o==east)) || (two_n==star && two_o==south) || (two_n==diamond && two_o==south)){
+                       check=true;
+                   }
+               }
+
+       }
+
+       // GREEN LEFT
+        if((one_n==equals && (one_o==north || one_o==east)) || (one_n==square && (one_o==north || one_o==east)) || (one_n==plus && (one_o==north || one_o==south))|| ((one_n==star || one_n==diamond) && one_o==south)){
+            if(two_pos==one_pos-1 && one_pos!=0 && one_pos!=3 && one_pos!=6){
+                if((two_n==plus && (two_o==north || two_o==south)) || ((two_n==equals || two_n==square) && (two_o==south || two_o==west)) || (two_n==star && two_o==north) || (two_n==diamond && two_o==north)){
+                    check=true;
+                }
+            }
+
+        }
+
+        // GREEN UP
+        if(((one_n==equals || one_n==square) && (one_o==east|| one_o==south)) || (one_n==plus && (one_o==east || one_o==west)) || ((one_n==star || one_n==diamond) && one_o==west)){
+            if(two_pos==one_pos-3 && one_pos!=1 && one_pos!=0 && one_pos!=2){
+                if((two_n==plus && (two_o==east || two_o==west)) || ((two_n==equals || two_n==square) && (two_o==north || two_o==west)) || ((two_n==star || two_n==diamond) && two_o==east)){
+                    check=true;
+                }
+            }
+
+        }
+
+        //GREEN DOWN
+        if(((one_n==equals || one_n==square) && (one_o==north|| one_o==west)) || (one_n==plus && (one_o==east || one_o==west))|| ((one_n==star || one_n==diamond) && one_o==east)){
+            if(two_pos==one_pos+3 && one_pos!=7 && one_pos!=6 && one_pos!=8){
+                if((two_n==plus && (two_o==east || two_o==west)) || ((two_n==equals || two_n==square) && (two_o==east || two_o==south)) || ((two_n==star || two_n==diamond) && two_o==west)){
+                    check=true;
+                }
+            }
+
+        }
+
+        //BROWN RIGHT
+        if(((one_n==triangle|| one_n==cross|| one_n==circle) && (one_o==south || one_o==west)) ||((one_n==star || one_n== diamond) && one_o==south)){
+            if(two_pos==one_pos+1 && one_pos!=2 && one_pos!=5 && one_pos!=8){
+                if( ((two_n==triangle || two_n==cross || two_n==circle) && (two_o==north || two_o==east)) || ((two_n==star || two_n==diamond) && two_o==north)){
+                    check=true;
+                }
+            }
+
+        }
+
+        //BROWN LEFT
+        if(((one_n==triangle|| one_n==cross|| one_n==circle) && (one_o==north || one_o==east)) ||((one_n==star || one_n== diamond) && one_o==north)){
+            if(two_pos==one_pos-1 && one_pos!=0 && one_pos!=3 && one_pos!=6){
+                if( ((two_n==triangle || two_n==cross || two_n==circle) && (two_o==south || two_o==west)) || ((two_n==star || two_n==diamond) && two_o==south)){
+                    check=true;
+                }
+            }
+
+        }
+
+        //BROWN UP
+        if(((one_n==triangle|| one_n==cross|| one_n==circle) && (one_o==south || one_o==east)) ||((one_n==star || one_n== diamond) && one_o==east)){
+            if(two_pos==one_pos-3 && one_pos!=0 && one_pos!=1 && one_pos!=2){
+                if( ((two_n==triangle || two_n==cross || two_n==circle) && (two_o==north || two_o==west)) || ((two_n==star || two_n==diamond) && two_o==west)){
+                    check=true;
+                }
+            }
+
+        }
+
+        //BROWN DOWN
+        if(((one_n==triangle|| one_n==cross|| one_n==circle) && (one_o==north || one_o==west)) ||((one_n==star || one_n== diamond) && one_o==west)){
+            if(two_pos==one_pos+3 && one_pos!=6 && one_pos!=7 && one_pos!=8){
+                if( ((two_n==triangle || two_n==cross || two_n==circle) && (two_o==east || two_o==south)) || ((two_n==star || two_n==diamond) && two_o==east)){
+                    check=true;
+                }
+            }
+
+        }
+
+        return check;  // Done Task 10
     }
 
     /** @return the orientation of this tile */
```
